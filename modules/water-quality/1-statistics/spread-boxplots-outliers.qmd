---
title: "Measures of Spread, Spotting Outliers"
format: live-html
sidebar: lesson-1
---

A second and final statistical measure we'll discuss today is **spread**. Just as it sounds, measures of spread tell us how spread out our data are. Spread, also referred to as **variability**, is *the backbone* of statistics!

**To-Do:** We need to re-load the class csv data since the webpage doesn't save things from page-to-page. Please paste the csv link again in the block below and run it.

```{pyodide}
import requests
import csv
from io import StringIO

# Replace the url with the one provided from your teacher. Make sure to keep the quotation marks!
csv_url = "www.replace_this_with_your_csv_url.csv"

# Get the data
response = requests.get(csv_url)
reader = csv.reader(StringIO(response.text))
next(reader)  # Skip header row

# Read all rows
rows = list(reader)

# Extract columns
class_nitrate = [int(row[3]) for row in rows]  # Fourth column (index 3)
class_nitrite = [int(row[4]) for row in rows]  # Fifth column (index 4)
```

## Two Measures of Spread
Today, we'll discuss two measures of spread: the **range** and the **standard deviation**.

### Range
The **range** is a fairly simple calculation. It's the biggest number minus the smallest number. Or, put differently, the maximum minus the minimum in a dataset.

:::{.ltorange-container}
**max()** - **min()**
:::

Here is an example of finding the range using our sample dataset:
```{pyodide}
sample_data = [1, 2, 6, 5, 1]

sample_range = max(sample_data) - min(sample_data)

print("Range of sample data:", sample_range)

```

**YOUR TURN:** Find the range of the class nitrate and class nitrate data! Fill in the `???` with the appropriate object name and run the block.
```{pyodide}
class_nitrate_range = max(???) - min(???)
class_nitrite_range = max(???) - min(???)

print("Range of class nitrate data:", class_nitrate_range)
print("Range of class nitrite data:", class_nitrite_range)
```

### Standard Deviation

How far numbers typically are from average (we'll explain this more later!)

**Example:** Which is more consistent?
- Stream A: pH readings of 7.0, 7.1, 7.0, 7.1 (very consistent!)
- Stream B: pH readings of 6.5, 7.5, 6.8, 7.9 (all over the place!)

## Understanding Standard Deviation

The **mean** tells us the average, but it doesn't tell us if the readings are consistent or all over the place.

**Standard deviation (SD)** tells us: **How spread out are the numbers?**

Think of it like this:

**Creek A:** pH readings are 7.1, 7.2, 7.1, 7.2, 7.1 (very consistent!)  
**Creek B:** pH readings are 6.5, 7.5, 6.8, 7.9, 6.6 (all over the place!)

Both might have similar means, but Creek A is more stable. Standard deviation measures this!

## What Standard Deviation Tells Us

- **Small SD** = Readings are close together (stable, consistent)
- **Large SD** = Readings are spread out (variable, inconsistent)

**Why it matters for water quality:**
- Stable readings = Good! Water conditions are consistent
- Variable readings = Investigate! Could be pollution events, sensor problems, or natural changes

## Calculating Standard Deviation
```{python}
import numpy as np

# Two example creeks with same mean but different consistency
creek_a = [7.1, 7.2, 7.1, 7.2, 7.1, 7.2, 7.1]  # Stable creek
creek_b = [6.5, 7.5, 6.8, 7.9, 6.6, 7.3, 7.4]  # Variable creek

mean_a = np.mean(creek_a)
std_a = np.std(creek_a)

mean_b = np.mean(creek_b)
std_b = np.std(creek_b)

print("Creek A (Stable):")
print(f"  Mean pH: {mean_a:.2f}")
print(f"  Standard Deviation: {std_a:.3f}")
print(f"  Readings are usually within {mean_a - std_a:.2f} to {mean_a + std_a:.2f}")

print("\nCreek B (Variable):")
print(f"  Mean pH: {mean_b:.2f}")
print(f"  Standard Deviation: {std_b:.3f}")
print(f"  Readings are usually within {mean_b - std_b:.2f} to {mean_b + std_b:.2f}")

print(f"\nCreek B has {std_b/std_a:.1f} times more variability!")
print("A scientist would want to investigate WHY Creek B is so variable.")
```

## Visualizing Standard Deviation
```{python}
import matplotlib.pyplot as plt
import numpy as np

# Same two example creeks
creek_a = [7.1, 7.2, 7.1, 7.2, 7.1, 7.2, 7.1]
creek_b = [6.5, 7.5, 6.8, 7.9, 6.6, 7.3, 7.4]

mean_a = np.mean(creek_a)
std_a = np.std(creek_a)
mean_b = np.mean(creek_b)
std_b = np.std(creek_b)

# Create side-by-side graphs
fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(14, 6))

days = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun']

# Creek A - Stable
ax1.plot(days, creek_a, marker='o', markersize=10, linewidth=2, color='blue')
ax1.axhline(y=mean_a, color='red', linestyle='--', linewidth=2, label=f'Mean = {mean_a:.2f}')
ax1.axhline(y=mean_a + std_a, color='orange', linestyle=':', linewidth=2, label='¬±1 SD')
ax1.axhline(y=mean_a - std_a, color='orange', linestyle=':', linewidth=2)
ax1.fill_between(range(len(days)), mean_a - std_a, mean_a + std_a, alpha=0.2, color='orange')
ax1.set_xlabel('Day of Week', fontsize=11)
ax1.set_ylabel('pH Level', fontsize=11)
ax1.set_title(f'Creek A: Very Consistent (SD = {std_a:.3f})', fontsize=12)
ax1.legend()
ax1.grid(True, alpha=0.3)
ax1.set_ylim(6, 8.5)

# Creek B - Variable
ax2.plot(days, creek_b, marker='o', markersize=10, linewidth=2, color='green')
ax2.axhline(y=mean_b, color='red', linestyle='--', linewidth=2, label=f'Mean = {mean_b:.2f}')
ax2.axhline(y=mean_b + std_b, color='orange', linestyle=':', linewidth=2, label='¬±1 SD')
ax2.axhline(y=mean_b - std_b, color='orange', linestyle=':', linewidth=2)
ax2.fill_between(range(len(days)), mean_b - std_b, mean_b + std_b, alpha=0.2, color='orange')
ax2.set_xlabel('Day of Week', fontsize=11)
ax2.set_ylabel('pH Level', fontsize=11)
ax2.set_title(f'Creek B: Very Variable (SD = {std_b:.3f})', fontsize=12)
ax2.legend()
ax2.grid(True, alpha=0.3)
ax2.set_ylim(6, 8.5)

plt.tight_layout()
plt.show()

print("The orange shaded area shows where most readings fall.")
print("Creek A: narrow band = consistent")
print("Creek B: wide band = variable")
```

## What Could Cause High Variability?

If a creek has high standard deviation (lots of variability), it might mean:

1. **Pollution events** - A factory dumps waste occasionally
2. **Storm runoff** - Rain washes fertilizer from farms into the creek
3. **Natural cycles** - Some creeks naturally vary (but usually not this much for pH)
4. **Sensor problems** - The equipment might need calibration
5. **Different sampling times** - Morning vs afternoon can be different

This is why **buoys** are so useful - they can measure continuously and help you see these patterns!

## Try It: Analyze Two Rivers
```{pyodide}
import numpy as np

# Example: River A - Near a farm
river_a_nitrate = [8.5, 9.2, 8.8, 9.0, 8.7, 9.1, 8.9]

# Example: River B - Near a forest
river_b_nitrate = [2.1, 2.3, 2.2, 2.4, 2.2, 2.3, 2.1]

# Calculate means and standard deviations
mean_a = np.mean(river_a_nitrate)
std_a = np.std(river_a_nitrate)

mean_b = np.mean(river_b_nitrate)
std_b = np.std(river_b_nitrate)

print("River A (Near Farm):")
print(f"  Mean nitrate: {mean_a:.2f} mg/L")
print(f"  Standard Deviation: {std_a:.3f} mg/L")

print("\nRiver B (Near Forest):")
print(f"  Mean nitrate: {mean_b:.2f} mg/L")
print(f"  Standard Deviation: {std_b:.3f} mg/L")

print("\nQuestions to think about:")
print("1. Which river has higher nitrate? (Look at the means)")
print("2. Which river is more consistent? (Look at the SD)")
print("3. Why might the farm river have higher nitrate?")
print("4. Is either river unsafe to drink? (Remember: safe is < 10 mg/L)")

# Try changing the numbers to see what happens!
```

## Your Future: Real Data Collection

Right now, you're practicing with example data that we created for learning. But soon you'll:

- üåä Deploy sensor buoys in real streams and creeks
- üìä Collect your OWN pH and nitrate data
- üî¨ Use these same Python skills to analyze YOUR measurements
- üìà See real patterns in water quality over time

Instead of 7 measurements, you might have 700! That's when mean and standard deviation become REALLY useful.

For now, let's keep practicing with examples so you'll be ready when it's time for real data collection!


### Measures of Spread
The measures of spread tell us how spread out a set of numbers are. There are two main measures of spread: the *standard deviation* and the *range*. We calculate them in different ways.

#### Standard Deviation
The *standard deviation* tells us: *How far, on average, are the numbers from the mean?* The formula for the standard deviation is a bit more complicated:

## What Are Outliers?

**Outliers** are data points that are very different from the rest of your data. They're the "weird" numbers that don't fit the pattern.

**Example:** pH readings from a creek: **7.1, 7.2, 7.0, 7.1, 12.3, 7.2**

That 12.3 is an outlier! It's way higher than everything else.

## Why Do Outliers Happen?

Outliers can happen for different reasons:

### 1. **Sensor Malfunction** üîß
- The sensor glitched or needs calibration
- Battery was dying
- Sensor got knocked around

### 2. **Real Pollution Event** üö®
- Factory dumped chemicals into the stream
- Farm fertilizer washed in after a storm
- Sewage spill

### 3. **Natural Event** üåßÔ∏è
- Heavy rain changed water chemistry
- Algae bloom
- Seasonal variation

**Your job as a scientist:** Figure out which reason it is!

## Why Outliers Matter for Water Quality

Outliers are REALLY important because:

1. **They might be pollution!** That weird high nitrate reading could mean someone dumped something bad
2. **They mess up your statistics** - Remember how the mean got messed up?
3. **They could mean broken equipment** - Your sensor might need fixing
4. **They tell a story** - What happened that day?

## Visualizing Outliers with a Box Plot

A **box plot** is a graph that shows outliers automatically! It's like a detective tool for finding weird data.
```{python}
import matplotlib.pyplot as plt

# Example: pH readings with some outliers
ph_data = [7.1, 7.2, 7.0, 7.3, 7.2, 7.1, 9.5, 7.2, 7.1, 7.0, 5.0, 7.3]

plt.figure(figsize=(10, 6))
plt.boxplot(ph_data, vert=True, patch_artist=True, 
            boxprops=dict(facecolor='lightblue'),
            medianprops=dict(color='red', linewidth=2))
plt.ylabel('pH Level', fontsize=12)
plt.title('Box Plot: Outliers Shown as Circles', fontsize=14)
plt.grid(True, alpha=0.3, axis='y')
plt.ylim(4, 10)

plt.text(1.15, 9.5, '‚Üê High outlier', fontsize=11, va='center')
plt.text(1.15, 5.0, '‚Üê Low outlier', fontsize=11, va='center')

plt.show()

print("The circles show outliers!")
print("The box shows where most of the 'normal' data is.")
```

**Reading a box plot:**
- The **line in the middle** = Median
- The **box** = Where the middle 50% of data is
- The **whiskers** (lines extending out) = Normal range
- The **circles** = Outliers!

## Try It: Detect Outliers
```{pyodide}
import numpy as np
import matplotlib.pyplot as plt

# Example: You're analyzing nitrate from a creek
# Is there an outlier?
creek_nitrate = [3.1, 3.2, 3.0, 3.3, 18.5, 3.1, 3.2, 3.0]

# Calculate IQR method
q1 = np.percentile(creek_nitrate, 25)
q3 = np.percentile(creek_nitrate, 75)
iqr = q3 - q1
lower_bound = q1 - 1.5 * iqr
upper_bound = q3 + 1.5 * iqr

print("Nitrate readings:", creek_nitrate)
print(f"\nOutlier boundaries: {lower_bound:.2f} to {upper_bound:.2f}")

# Find outliers
outliers = [x for x in creek_nitrate if x < lower_bound or x > upper_bound]
print(f"Outliers found: {outliers}")

# Make a box plot
plt.figure(figsize=(8, 6))
plt.boxplot(creek_nitrate, vert=True, patch_artist=True,
            boxprops=dict(facecolor='lightgreen'))
plt.ylabel('Nitrate (mg/L)', fontsize=12)
plt.title('Box Plot of Creek Nitrate', fontsize=13)
plt.grid(True, alpha=0.3, axis='y')
plt.show()

# Try removing the 18.5 and run it again!
```

## What Should You Do with Outliers?

Once you find an outlier, you have some choices:

### Option 1: Keep It ‚úÖ
**When to do this:**
- It's a real measurement (like a pollution event)
- You want to study what caused it
- It's important for your research
```{python}
# Example: Keep the outlier because it's a real pollution event
data_with_outlier = [2.1, 2.3, 2.2, 15.0, 2.4, 2.2]
print("Data with outlier:", data_with_outlier)
print(f"Mean: {np.mean(data_with_outlier):.2f}")
print("\nWe keep it because it shows a pollution event happened!")
```

### Option 2: Remove It üóëÔ∏è
**When to do this:**
- It's clearly a sensor error
- It's impossible (like pH of 20)
- You want to see typical conditions
```{python}
# Example: Remove the outlier because it's a sensor error
data_with_outlier = [7.1, 7.2, 7.0, 15.0, 7.2, 7.1]
data_cleaned = [x for x in data_with_outlier if x < 10]  # Remove anything above 10

print("Original data:", data_with_outlier)
print("Cleaned data:", data_cleaned)
print(f"\nMean before: {np.mean(data_with_outlier):.2f}")
print(f"Mean after: {np.mean(data_cleaned):.2f}")
print("\nMuch better! Now the mean makes sense.")
```

### Option 3: Investigate It üîç
**Always do this first!**
- Check your field notes - What happened that day?
- Look at weather data - Was there a storm?
- Check the sensor - Is it working correctly?
- Ask: Is this reading even possible?

## Real-World Detective Work

Let's practice being water quality detectives!
```{python}
import numpy as np
import matplotlib.pyplot as plt

# Scenario: You're monitoring a stream near a farm
# Here are nitrate readings over 2 weeks
days = list(range(1, 15))
nitrate = [2.1, 2.3, 2.2, 2.4, 2.2, 8.5, 9.2, 3.0, 2.8, 2.9, 2.7, 2.8, 2.9, 2.6]

# Plot it
plt.figure(figsize=(12, 6))
plt.plot(days, nitrate, marker='o', markersize=10, linewidth=2, color='brown')
plt.axhline(y=np.median(nitrate), color='green', linestyle='--', linewidth=2, label='Median')
plt.axhline(y=10, color='red', linestyle='--', linewidth=2, alpha=0.5, label='EPA Limit')

# Highlight the spike
plt.scatter([6, 7], [8.5, 9.2], s=300, color='red', marker='X', zorder=5, label='Spike!')

plt.xlabel('Day', fontsize=12)
plt.ylabel('Nitrate (mg/L)', fontsize=12)
plt.title('Mystery: What Happened on Days 6-7?', fontsize=14)
plt.legend(fontsize=11)
plt.grid(True, alpha=0.3)
plt.show()

print("Detective Questions:")
print("1. Are Days 6-7 outliers? (YES - much higher than others)")
print("2. Are they sensor errors? (Probably NOT - both days show high values)")
print("3. What could cause this? (Possible: Heavy rain ‚Üí fertilizer runoff)")
print("4. Should we remove them? (NO - this is real data showing an event!)")
print("\nConclusion: This looks like a real pollution event to investigate!")
```

## Comparing With and Without Outliers
```{python}
import numpy as np

# Example: Creek pH data with one bad sensor reading
creek_ph = [7.1, 7.2, 7.0, 7.2, 14.5, 7.1, 7.2]

# Calculate statistics both ways
print("WITH the outlier (14.5):")
print(f"  Mean: {np.mean(creek_ph):.2f}")
print(f"  Median: {np.median(creek_ph):.2f}")
print(f"  Standard Deviation: {np.std(creek_ph):.2f}")

# Remove the outlier (14.5 is impossible for creek water)
creek_ph_clean = [x for x in creek_ph if x < 10]

print("\nWITHOUT the outlier:")
print(f"  Mean: {np.mean(creek_ph_clean):.2f}")
print(f"  Median: {np.median(creek_ph_clean):.2f}")
print(f"  Standard Deviation: {np.std(creek_ph_clean):.2f}")

print("\nSee how much more accurate the statistics are without the bad reading?")
```

## Your Future: Outliers in Buoy Data

When you deploy sensor buoys in real streams, you'll see outliers! Some will be:

**Real events to study:**
- üåßÔ∏è Storm runoff events
- üè≠ Pollution spills
- ü¶† Algae blooms
- üåä Seasonal changes

**Equipment issues to fix:**
- üîã Low battery
- üîß Sensor needs calibration
- üì° Data transmission errors
- üêü Something bumped the sensor

The skills you're learning now will help you tell the difference!

## Quick Reference: Finding Outliers
```python
# IQR Method (copy this code!)
import numpy as np

data = [your_readings_here]

# Calculate boundaries
q1 = np.percentile(data, 25)
q3 = np.percentile(data, 75)
iqr = q3 - q1
lower = q1 - 1.5 * iqr
upper = q3 + 1.5 * iqr

# Find outliers
outliers = [x for x in data if x < lower or x > upper]
print("Outliers:", outliers)
```

## Try It: Multiple Outliers
```{pyodide}
import numpy as np
import matplotlib.pyplot as plt

# Example: pH readings with several outliers
ph_readings = [7.1, 7.2, 7.0, 9.5, 7.2, 7.1, 5.5, 7.3, 7.2, 7.1, 12.0, 7.2]

# Make a box plot
plt.figure(figsize=(10, 6))
plt.boxplot(ph_readings, vert=True, patch_artist=True,
            boxprops=dict(facecolor='lightcoral'))
plt.ylabel('pH', fontsize=12)
plt.title('How Many Outliers Can You Spot?', fontsize=13)
plt.grid(True, alpha=0.3, axis='y')
plt.show()

# Calculate IQR method
q1 = np.percentile(ph_readings, 25)
q3 = np.percentile(ph_readings, 75)
iqr = q3 - q1
lower = q1 - 1.5 * iqr
upper = q3 + 1.5 * iqr

outliers = [x for x in ph_readings if x < lower or x > upper]

print("pH readings:", ph_readings)
print(f"Outliers detected: {outliers}")
print("\nWhat do you think caused each outlier?")
```

## Key Takeaways

- üîç **Outliers** = Data points that don't fit the pattern
- ‚ö†Ô∏è They could mean: pollution events, sensor errors, or data mistakes
- üìä **IQR method** = Math way to find outliers automatically
- üìâ **Box plots** = Visual way to spot outliers (shown as circles)
- ü§î Always **investigate** before removing outliers
- ‚úÖ Keep outliers if they're real events worth studying
- üóëÔ∏è Remove outliers if they're equipment errors
- üåä Real stream data will have outliers - you need to understand them!

## The Decision Tree

When you find an outlier, ask yourself:

1. **Is it possible?** (pH of 20 = No, pH of 8.5 = Yes)
2. **What happened that day?** (Check notes, weather, etc.)
3. **Does it fit a pattern?** (One spike vs multiple high readings)
4. **Is the sensor working?** (Check calibration, battery)

Then decide: Keep it, remove it, or investigate more!

**Next lesson:** We'll learn about scatterplots - how to see if two things (like pH and nitrate) are related!